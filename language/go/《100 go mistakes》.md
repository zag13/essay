# 《100 go mistakes》

[思维导图](/mind.html?path=/language/go/《100%20go%20mistakes》&initialexpandlevel=2)

## 代码和项目组织

1. **意外的变量隐藏** 要注意短声明是否会覆盖原先变量
2. **不必要的嵌套代码** 简单可读，尽早返回
3. **滥用 init 函数** init 在变量声明之后，main 函数之前执行，多个 init 函数按照声明顺序执行
4. **过度使用 getter 和 setter** 尽量使用直接访问，不要过度封装
5. **接口污染** 若无必要，勿增实体（抽象应该是被发现，而不是被创建）
6. **生产者的接口** 一般放在消费端维护，若确有必要放在生产者一方，应尽量减小抽象
7. **返回接口** 一般返回具体抽象
8. **any 意味着 nothing** any 丢失了类型信息，使用时应谨慎
9. **乱用泛型** 应在一些通用的数据结构和函数中使用
10. **误用嵌入类型** 小心方法提升
11. **不使用函数选项模式** 萝卜青菜，各有所爱
12. **项目无组织** 社区公约 golang-standards
13. **创建通用包** 不推荐 common、util、shared 等没有具体含义的包
14. **变量和包名冲突** 小心变量和包名冲突
15. **缺少代码文档** 每个导出的元素都应有文档
16. **不使用 linters** 磨刀不误砍柴工

## 数据类型

17. **使用 8 进制字面量** 二进制：`0b`，八进制：`0o`，十六进制：`0x`
18. **忽略整数溢出** Go 对溢出是静默的
19. **不了解浮点数** float32 精度 7 位，float64 精度 15 位
20. **不了解切片的长度和容量** 长度是指切片中元素的个数，容量是指底层数组中元素的个数
21. **低效的切片初始化** 初始化时指定容量，避免频繁扩容
22. **对 nil 和空切片的困惑** nil 和空切片的长度都为0，nil 不需要分配
23. **不正确检查切片为空** `len(s) != 0`
24. **不正确复制切片** `copy(dst, src)` 会复制 `min(len(dst), len(src))` 个元素
25. **忽视 append 的副作用** append 可能会导致底层数组重新分配，导致之前的切片失效
26. **切片内存泄露** 切片容量泄漏、底层数组泄漏
27. **低效的 map 初始化** 初始化时指定容量，避免频繁扩容
28. **map 内存泄漏** map 的桶会随着元素的增加而增加，但是不会随着元素的删除而减少
29. **比较值时犯错** `reflect.DeepEqual()`
    - **Booleans** 比较两个布尔值是否相等
    - **Numerics** 比较数字是否相等
    - **Strings** 比较字符串是否相等
    - **Channels** 比较两个通道是否指向同一个通道或者都是 nil
    - **Interfaces** 比较两个接口是否具有相同的动态类型且值相等或者都是 nil
    - **Pointers** 比较两个指针是否指向同一个对象或者都是 nil
    - **Structs and Arrays** 比较结构体或者数组的每个元素是否相等

## 控制结构

30. **忽视遍历时元素被复制** for range 时， 元素会被复制，修改的是副本
31. **忽视遍历时表达式怎么计算** for range 时，表达式只会计算一次；若需要每次都计算，应使用普通 for 循环
32. **忽视遍历时指针元素的影响** for range 时，元素都会分配给一个具有唯一地址的变量，每次迭代存储引用该指针的变量的话，只会存储最后的值
33. **遍历 map 时想当然** map 是无序的，每次遍历的顺序都可能不一样；遍历时插入元素，可能会出现在遍历中，也可能被跳过
34. **忽视 break 的工作机制** break 只会跳出当前循环，若想跳出多层循环，应使用标签
35. **在循环中使用 defer** 会堆积所有 defer，如果循环没有终止，会导致内存泄漏
101. **忽视闭包中的参数** 闭包中的参数是引用，而不是值

## 字符串

36. **不理解 rune** rune 是 int32 的别名，可以由多个字节组成；len(s) 返回的是字节数，而不是字符数
37. **不正确的字符串遍历** for range 遍历字符串时，会将字符串转换为 rune 数组，而不是字节数组
38. **乱用 trim** 要了解 `strings.TrimRight() strings.TrimSuffix()` 的区别
39. **未对字符串连接进行优化** 使用 `strings.Builder` 进行字符串拼接
40. **无用的字符串转换** 确认需不需要对 string 和 []byte 进行互转
41. **字符串内存泄漏** 子串占用母串

## 函数与方法

42. **不知道选择哪种接收器类型** 若需要修改接收器的值或其中包含一个无法复制的字段，必须使用指针接收器
43. **从不使用命名的返回值** 提升代码可读性
44. **未预期的命名返回值的副作用** 注意变量隐藏
45. **返回一个 nil 接收器** nil 接收器 != nil ⭐️⭐️⭐️
46. **使用文件名作为函数输入** 增加代码测试的复杂性
47. **忽视 defer 的参数和接收器的评估** defer 会在函数返回前执行，但是参数和接收器是在使用 defer 语句是评估的；可以使用闭包

## 错误管理

48. **panic** 谨慎使用 panic
49. **忽视何时封装错误** `fmt.Errorf("detail error: %w", err)`
50. **不准确的错误类型检查** 使用 `errors.As()` 对封装后的错误类型进行检查
51. **不准确的错误值检查** 使用 `errors.Is()` 对封装后的错误值进行检查
52. **两次处理同一个错误** 要么记录日志，要么返回错误（可以使用 `fmt.Errorf()` 进行封装）
53. **不处理错误** 对某个错误不感兴趣，将其赋值给 `_` 语义会更明确
54. **不处理 defer 中的错误** 有可能导致资源未被释放

## 并发：基础

55. **混淆并发和并行** 并发是指两个或多个任务在时间上重叠，而并行是指两个或多个任务在同一时刻执行
56. **认为并发总是更快** 当任务开销小于 goroutine 的开销时，并发会降低性能
57. **不知道使用 channel 还是 mutex** 一般来说，并发 goroutines 需要使用 channel，而并行 goroutines 需要使用 mutex
58. **不理解竞争问题** 原子操作；使用互斥锁；使用 channel
59. **不知道工作负载类型** CPU 密集型、I/O 密集型
60. **不理解 Go context** context 用于在 goroutine 之间传递请求作用域的数据、取消信号和截止日期

## 并发：实践

61. **传播不恰当的 context** 