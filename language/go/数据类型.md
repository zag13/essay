# 数据类型

## new 和 make

new 返回一个类型`T`的**零值**的指针。
函数签名为`func new(Type) *Type`

make 用于创建 slice、map、channel，返回一个类型为`T`（非`*T`）的*已初始化的*（非零值）的值。
函数签名为`func make(t Type, size ...IntegerType) Type`

## 基础类型

基础类型包括数字、字符串和布尔型。

### 整数

有符号整数：int8、int16、int32、int64

无符号整数：uint8、uint16、uint32、uint64

rune 是 int32 的同义词，常用于指明一个值是 Unicode 码点。byte 是 uint8 的同义词，强调一个值是原始数据，而非量值。
同义词之间可互换使用。

int 和 uint 的大小取决于运行平台。uintptr 的大小也不明确，但足以完整存放指针。

### 浮点数

浮点数：float32、float64

十进制下，float32 的有效数字约为6位，float64 的有效数字约为15位。

### 复数

复数：complex64、complex128

### 布尔值

布尔值：true、false

### 字符串

字符串是不可变的字节序列，它可以包含任意数据，包括0值字节。

`len` 返回的是字符串的字节数，_下标访问_`s[i]`则是第i个字符。

### 常量

常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。

## 聚合类型

聚合类型包括数组、slice、map和结构体。其中 slice 和 map 也是引用类型，故放在了下一章节。

### 数组

数组是具有*固定长度*且拥有零个或多个相同数据类型元素的序列。

数组的长度是数组类型的一部分。

如果一个数组的元素类型是*可比较*的，那么这个数组也是*可比较*的。

### 结构体

结构体是将零个或者多个任意类型的命名变量组合在一起的聚合数据类型。

结构体的零值由结构成员的零值组成。

成员变量的顺序是结构体类型的一部分。

成员变量的访问控制是通过首字母的大小写来控制的。

命名结构体类型S不可以定义类型为S的成员变量，但是可以定义一个S的指针变量。

结构体嵌套...

## 引用类型

### slice

slice是具有*可变长度*的相同数据类型元素的序列。

slice拥有三个属性：指针、长度和容量。指针指向数组的第一个可以从slice中访问的元素，这个元素不一定是数组的第一个元素。
长度是指slice中的元素个数，它不能超过slice的容量。容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数。

一个底层数组可以对应多个slice，这些slice可以引用数组的任何位置，彼此之间的元素还可以重叠。

slice操作符`s[i:j] (0 <= i <= j <= cap(s))`创建了一个新的slice，其引用了序列s中从i到j-1索引位置的所有元素。
如果slice的引用超过了被引用对象的容量，则会导致宕机；但是只是超过了被引用对象的长度，那么最终slice会比原slice长。

与数组不同的是，slice无法做比较，因此不能通过`==`来测试两个slice是否拥有相同的元素。两个原因。首先，slice的元素是非直接的。
其次，因为slice的元素不是直接的，如果底层数组改变，同一个slice在不同的时间会拥有不同的元素。
这也是slice不能作为map的键的原因，map仅对元素的键做浅拷贝。

通常情况下，我们并不清楚一次调用append函数会不会导致一次新的内存分配，所以我们不能假设原始的slice和调用append后的结构slice指向同一个底层数组，
也无法证明它们指向不同的底层数组。同样，我们也无法假设就slice上对元素的操作会或者不会影响新的slice元素。
所以，通常我们这样使用`runes = append(runes, r)`。

### map

map是散列表的引用，类型为`map[K]V`，其中K和V是字典的键和值对应的数据类型。

可以使用内置函数make创建一个map，也可以使用map的字面量来创建。元素的添加和访问是通过下标`m['zag']`，删除是通过内置函数delete。
（即使键不在map中，上面的操作也是安全的。）

map元素不是一个变量，不可以获取它的地址。`_ = &m["zag"] // 编译失败`。
一个原因是，map的增长可能会导致已有元素被重新散列到新的存储位置，这样就可能使得获得的地址无效。

map中元素的迭代顺序是不固定的。如果需要按照某种顺序来遍历map中的元素，必须显示地来给键排序。

和slice一样，map不可比较，唯一合法的比较就是和nil做比较。为了判断两个map是否拥有相同的键和值，必须写一个循环。

### 指针

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在32和64位机器上分别占用4或8个字节，占用字节的大小与所指向的值的大小无关。
当一个指针被定义后没有分配到任何变量时，它的默认值为nil。指针变量通常缩写为ptr。

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加&操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：
`ptr := &v // v 的类型为 T`其中v代表被取地址的变量，变量v的地址使用变量ptr进行接收，ptr的类型为*T，称做T的指针类型，*代表指针。

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用*操作符，也就是指针取值，

### 函数

每个函数声明都包含一个名字、一个形参列表、一个可选的返回列表以及函数体：`func name(parameter-list) (result-list) { body }`

函数的类型称做*函数签名*。当两个函数拥有相同的形参列表和返回列表时，认为这两个函数的类型或签名是相同的。

形参变量都是函数的局部变量，初始值由调用者提供的实参传递。函数形参以及命名返回值同属于函数最外层作用域的局部变量。

实参是*按值*传递的，所以函数接收到的是每个实参的副本；修改函数的形参变量并不会影响到调用者提供的实参。
然而，如果提供的实参包含引用类型，比如slice、map、指针、函数或者通道，那么当函数使用形参变量时就有可能会*间接的*修改实参变量。

函数字面量就像函数声明，但在func关键字后面没有函数的名称。它是个表达式，它的值被称为*匿名函数*。
当一个匿名函数需要进行递归，必须先声明一个变量然后将匿名函数赋给这个变量。

**警告：捕获迭代变量**  在循环里创建的所有*函数变量*共享相同的变量————一个可访问的存储地址，而不是固定的值。

在参数列表最后的类型名称之前使用省略号"..."表明声明一个变长函数，调用这个函数的时候可以传递该类型任意数目的参数。
调用者也可以将一个slice传递给变长函数，在slice后放一个省略号。

在函数或者方法调用之前加上关键词`defer`，延迟执行的函数在执行`return`（`panic`）之后执行，并且可以更新函数的结果变量。
因为匿名函数可以得到其外层函数作用域内的变量（包括命名的结果），所以延迟执行的匿名函数可以观察到函数的返回结果。
defer语句没有限制使用次数；执行的时候以调用defer语句顺序的倒序进行。

---

*方法*是特定类型的函数。声明时在函数名字前面多加一个参数，这个参数吧这个方法绑定到这个参数对应的类型上。

同一个包下的任何类型都可以声明方法，只要它的类型既不是指针类型也不是接口类型。

方法调用需要符合其中任意一个条件：实参接受者和形参接受者是同一个类型、实参接受者是`T`类型的*变量*而形参接受者是`*T`类型、
实参接受者是`*T`类型而形参接受者是`T`类型。

### 通道

## 接口类型