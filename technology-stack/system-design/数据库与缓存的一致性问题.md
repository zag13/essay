# 数据库和缓存的一致性问题？

> [如何保持mysql和redis中数据的一致性？](https://www.zhihu.com/question/319817091)

**根据是否接收写请求，可以把缓存分成读写缓存和只读缓存**

- **只读缓存**  只在缓存进⾏数据查找，即使⽤ “**更新数据库+删除缓存**” 策略
    - **新增数据时**，写⼊数据库；访问数据时，缓存缺失，查数据库，更新缓存（始终是处于”数据⼀致“的状态， 不会发⽣数据不⼀致性问题)
    - **更新（修改/删除）数据时**，会有个时序问题：更新数据库与删除缓存的顺序（这个过程会发⽣数据不⼀致性问题）
        - 无并发请求下，后者存在操作失败的可能（解决方案：方案一、方案二）
        - 并发请求下，其它线程读到旧值（单独捞出来下）
- **读写缓存**  需要在缓存中对数据进⾏增删改查，即使⽤ “**更新数据库+更新缓存**”策略
    - **同步直写**  使⽤事务，保证缓存和数据更新的原⼦性，并进⾏失败重试（如果Redis 本身出现故障，会降低 服务的性能和可⽤性）
        - 无并发请求下，后者存在操作失败的可能（解决方案：方案一、方案二）
        - 并发请求下，情况较复杂（单独捞出来下）
    - **异步回写**  写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库（没写回数据库前，缓存发生故障，会造成数据丢失）
      该策略在秒杀场中有⻅到过，业务层直接对缓存中的秒杀商品库存信息进⾏操作，⼀段时间后再回写数据库。

**高并发情况下，更新只读缓存会出现的问题**

- **先删除缓存，再更新数据库**

假设线程 A 删除缓存值后，由于⽹络延迟等原因导致未及更新数据库，⽽此时，线程 B 开始读取数据时会发现缓存缺失，进⽽去查询数据库。⽽当线程
B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，会导致缓存中的数据是旧值，⽽数据库中的是最新值，产⽣“数据不⼀致”。（解决方案：方案三）

- **先更新数据库，再删除缓存**

  如果线程 A 更新了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B
  查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。或者，在”先更新数据库，再删除缓存”⽅案下，“读写分离 +
  主从库延迟”也会导致不⼀致。（解决方案：方案二、方案四、方案五）

**高并发情况下，更新读写缓存会出现的问题**

- 先更新缓存，再更新数据库
    - 「读+写」并发（影响小）
    - 「写+写」并发（影响大，方案六）
- 先更新数据库，再更新缓存
    - 「读+写」并发（影响小）
    - 「写+写」并发（影响大，方案六）


- **方案一 「消息队列+异步重试」**

- **方案二 「订阅Binlog变更日志」**

- **方案三 「设置缓存过期时间 + 延时双删」**

  通过设置缓存过期时间，若发⽣淘汰缓存失败的情况，则在缓存过期后，读请求仍然可以从DB中读取最新数据并更新缓存，可减⼩数据不⼀致的影响范围。虽然在⼀定时间范围内数据有差异，但可以保证数据的最终⼀致性。

  此外，还可以通过延时双删进⾏保障：在线程 A 更新完数据库值以后，让它先 sleep ⼀⼩段时间，确保线程 B 能
  够先从数据库读取数据，再把缺失的数据写⼊缓存，然后，线程 A 再进⾏删除。后续，其它线程读取数据时，发现缓存缺失，会从数据库中读取最新值。

- **方案四 「延迟消息」**

  凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不⼀致发⽣的概率。

- **方案五 「加锁」**

  更新数据时，加写锁；查询数据时，加读锁

- **方案六 「分布式锁」**

  对于写请求，需要配合分布式锁使用。写请求进来时，针对同⼀个资源的修改操作，先加分布式锁，保证同⼀时间只有⼀个线程去更新数据库和缓存；没有拿到锁的线程把操作放⼊到队列中，延时处理。⽤这种⽅式保证多个线程操作同⼀资源的顺序性，以此保证⼀致性




