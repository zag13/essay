# 锁

InnoDB 实现了两种类型的行级锁：

- **共享锁** （也称为 S 锁）：允许事务读取一行数据

  `select * from tableName where... lock in share mode;`   手动加 S 锁

- **独占锁** （也称为 X 锁）：允许事务删除或更新一行数据

  `select * from tableName where... for update`; 手动加 X 锁

  > S 锁和 S 锁是 **兼容** 的，X 锁和其它锁都 **不兼容**

为了实现多粒度的锁机制，InnoDB 还有两种内部使用的 **意向锁** ，由 InnoDB 自动添加，且都是表级别的锁：

- **意向共享锁** （IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁

- **意向排他锁** （IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁
  | **锁类型** | **X** | **IX** | **S** | **IS** |
  | :--------- | :---- | :----- | :---- | :----- |
  | **X**      | 冲突 | 冲突 | 冲突 | 冲突 |
  | **IX**     | 冲突 | 兼容 | 冲突 | 兼容 |
  | **S**      | 冲突 | 冲突 | 兼容 | 兼容 |
  | **IS**     | 冲突 | 兼容 | 兼容 | 兼容 |

**行锁的算法：**

- **Record Locks：** 该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录
- **Gap Locks：** 该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 `READ COMMITTED`
  或者配置 `innodb_locks_unsafe_for_binlog` 参数为 `ON`
- **Next-key Locks：** 该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key
  Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。

**死锁：**

**死锁** 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

InnoDB 引擎采取的是 `wait-for graph` 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。

**锁的优化建议：**

- 合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。
- 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
- 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。
- 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。

