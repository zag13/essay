# 事务

[思维导图](/mind.html?path=/data-system/mysql/事务)

事务是一组数据库操作，被视为一个单一的逻辑单位，要么全部成功执行，要么全部回滚。

1. 开始事务： 使用`START TRANSACTION`，或者`BEGIN`来标记一个事务的开始。
2. 执行SQL操作： 执行数据库操作，如插入、更新、删除等。
3. 提交或回滚： 根据操作的结果，可以选择`COMMIT`，提交事务，使其生效；或者`ROLLBACK`，回滚事务，取消之前的操作。

## 特性

- **原子性（Atomicity）** 事务的所有操作要么全部成功执行，要么全部回滚。不存在部分执行的情况。

  MySQL 在执行事务期间，将操作记录在事务日志（Transaction Log）中，该日志会记录每个操作的详细信息。
  在事务提交之前，所有的操作被写入到事务日志中，如果事务成功提交，这些操作将被应用到数据库中，否则会根据事务日志进行回滚。

- **一致性（Consistency）** 事务开始前和结束后，数据库的状态必须保持一致。这意味着事务执行前后，数据库从一个合法状态转变为另一个合法状态。

  MySQL 使用 MVCC (多版本并发控制) 来实现一致性。
  MVCC 允许多个事务并发访问数据库，但每个事务只能看到自己提交之前的数据。
  这样可以确保每个事务看到的数据都是一致的。

- **隔离性（Isolation）** 同时执行的多个事务在彼此看来好像是独立的，一个事务的执行不应该受到其他事务的干扰。

  MySQL 通过使用各种锁和事务隔离级别来实现隔离性。
  事务隔离级别包括读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。
  不同的隔离级别提供了不同的锁定和读取行为，以满足不同的并发需求。

- **持久性（Durability）** 一旦事务提交，其对数据库的修改将是永久性的，即使系统发生故障也不会丢失。

  MySQL 通过重做日志（Redo Log）来实现持久性。
  在发生崩溃等情况时，数据库系统可以根据重做日志中的记录，重新执行这些操作，确保数据的一致性和完整性。

### 隔离性

- **脏写：** 事务 B 修改了事务 A 修改过但尚未提交的数据，就意味着发生了**脏写**（反之亦然）
- **脏读：** 事务 B 读取到了事务 A 修改过但未提交的数据，就意味着发生了**脏读**（反之亦然）
- **不可重复读：** 事务 B 能够读取事务 A 提交过的修改数据，就意味着发生了**不可重复读**（反之亦然）
- **幻读：** 事务 B 先通过指定条件查询出一些记录，然后事务 A 又向该表插入了符合同样条件的记录；事务 B 再次按照同样条件查询时，能够把事务
  A 插入的记录也读取出来，就意味着发生了**幻读**（反之亦然）

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 备注 |
|------------------------|-------|-------|-------|---｜
| 读未提交（Read uncommitted） | 可以出现 | 可以出现 | 可以出现 ||
| 读提交（Read committed） | 不允许出现 | 可以出现 | 可以出现 ||
| 可重复读（Repeatable read） | 不允许出现 | 不允许出现 | 可以出现 | 通过 `next-key locks` 机制来避免幻读 |
| 序列化（Serializable ） | 不允许出现 | 不允许出现 | 不允许出现 |
完全串行化读写数据，每次读都需要获得表级共享锁，读写相互都会阻塞 |

## 日志系统

## 锁